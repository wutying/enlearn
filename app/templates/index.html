{% extends "base.html" %}
{% block title %}æ–°å¢å–®å­—ï½œéš¨èº«å–®å­—æœ¬{% endblock %}
{% block content %}
<section class="card new-entry-card">
  <h2>å¿«é€Ÿæ–°å¢å–®å­—</h2>
  <form method="post" action="{{ url_for('add_entry_route') }}" class="form-grid" data-add-entry>
    <label>
      å–®å­— / ç‰‡èª
      <input type="text" name="word" placeholder="ex: serendipity" required />
      <small class="input-hint">è¼¸å…¥å¾Œæœƒè‡ªå‹•æŸ¥è©¢ä¸¦å¸¶å…¥ç¿»è­¯ï¼Œé€å‡ºæ™‚æœƒæœ—è®€ä¸€æ¬¡åŠ æ·±å°è±¡ã€‚</small>
    </label>
    <label>
      è§£é‡‹æˆ–ç¿»è­¯
      <textarea name="definition" rows="3" placeholder="ex: æ„å¤–å¾—åˆ°çš„é©šå–œæ”¶ç©«" required></textarea>
      <small id="lookup-status" class="lookup-status" aria-live="polite"></small>
    </label>
    <label>
      æƒ…å¢ƒæˆ–ä¾‹å¥ï¼ˆé¸å¡«ï¼‰
      <textarea name="context" rows="3" placeholder="ex: Finding the cafÃ© was pure serendipity."></textarea>
    </label>
    <button type="submit" class="btn-primary">åŠ å…¥å–®å­—</button>
  </form>
</section>

<section class="card vocabulary-card">
  <div class="section-heading">
    <h2>å–®å­—æœ¬</h2>
    <p>ä»Šæ—¥å¾…è¤‡ç¿’ï¼š<strong>{{ due_count }}</strong> å€‹å–®å­—ã€‚</p>
  </div>
  <p class="storage-hint">è³‡æ–™æœƒå„²å­˜åœ¨ <code>{{ storage_path }}</code>ï¼Œæ–¹ä¾¿å‚™ä»½æˆ–åŒæ­¥ã€‚</p>
  {% if entries %}
    <table class="entries">
      <thead>
        <tr>
          <th scope="col">å–®å­—</th>
          <th scope="col" class="definition-column">è§£é‡‹</th>
          <th scope="col">ä¸‹ä¸€æ¬¡è¤‡ç¿’</th>
          <th scope="col">é€£å‹</th>
          <th scope="col">è¤‡ç¿’æ¬¡æ•¸</th>
        </tr>
      </thead>
      <tbody>
        {% for entry in entries %}
          <tr>
            <td class="word-cell">
              <span class="word-text">{{ entry.word }}</span>
              <button
                type="button"
                class="speak-button"
                data-speak-word="{{ entry.word }}"
                aria-label="æ’­æ”¾ {{ entry.word }} çš„ç™¼éŸ³"
              >
                ğŸ”ˆ
              </button>
            </td>
            <td class="definition-cell" data-collapsible data-expanded="false">
              <div class="definition-content" data-collapsible-content>
                <p>{{ entry.definition }}</p>
                {% if entry.context %}
                  <p class="context">{{ entry.context }}</p>
                {% endif %}
              </div>
              <button type="button" class="definition-toggle" data-collapsible-toggle>å±•é–‹æ›´å¤š</button>
            </td>
            <td>{{ entry.next_review }}</td>
            <td>{{ entry.success_streak }}</td>
            <td>{{ entry.review_count }}</td>
          </tr>
        {% endfor %}
      </tbody>
    </table>
  {% else %}
    <p>é‚„æ²’æœ‰å–®å­—ï¼Œè¶•å¿«æ–°å¢ä¸€å€‹å§ï¼</p>
  {% endif %}
</section>

<section class="card review-overview">
  <h2>è¤‡ç¿’å–®å­—</h2>
  <p>é¸æ“‡æƒ³è¦çš„è¤‡ç¿’æ¨¡å¼å¾Œï¼Œå†é–‹å§‹é€²è¡Œä»Šæ—¥çš„ç·´ç¿’ã€‚</p>
  <form method="get" action="{{ url_for('review') }}" class="review-mode-form">
    <fieldset class="review-mode-options">
      <legend class="sr-only">è¤‡ç¿’æ¨¡å¼</legend>
      <label class="mode-option">
        <input type="radio" name="mode" value="word-first" checked />
        <div class="mode-option__content">
          <h3>é¡¯ç¤ºå–®å­—çŒœè§£é‡‹</h3>
          <p>é©åˆåŠ å¼·ç†Ÿæ‚‰åº¦ï¼Œæœ—è®€å–®å­—å¾Œå†æ­éœ²æ„æ€ã€‚</p>
        </div>
      </label>
      <label class="mode-option">
        <input type="radio" name="mode" value="definition-first" />
        <div class="mode-option__content">
          <h3>é¡¯ç¤ºè§£é‡‹è¼¸å…¥å–®å­—</h3>
          <p>çœ‹åˆ°ä¸­æ–‡æˆ–è§£é‡‹ï¼Œè¼¸å…¥å°æ‡‰è‹±æ–‡ï¼Œæª¢é©—æ˜¯å¦çœŸçš„è¨˜ä½ã€‚</p>
        </div>
      </label>
    </fieldset>
    <button type="submit" class="btn-primary">å‰å¾€è¤‡ç¿’ï¼ˆå°šæœ‰ {{ due_count }} å€‹ï¼‰</button>
  </form>
</section>
{% endblock %}

{% block extra_scripts %}
  <script>
    (function () {
      const wordInput = document.querySelector('input[name="word"]');
      const defInput = document.querySelector('textarea[name="definition"]');
      const statusEl = document.getElementById('lookup-status');

      if (!wordInput || !defInput || !statusEl) {
        return;
      }

      const focusWordInput = () => {
        wordInput.focus();
        if (typeof wordInput.select === 'function') {
          wordInput.select();
        }
      };

      focusWordInput();

      let definitionManuallyEdited = false;
      let manualEditWord = '';
      let lookupDelay = null;
      let activeController = null;

      const setStatus = (message, state) => {
        statusEl.textContent = message;
        statusEl.dataset.state = state;
      };

      const cancelLookup = () => {
        if (lookupDelay) {
          clearTimeout(lookupDelay);
          lookupDelay = null;
        }
        if (activeController) {
          activeController.abort();
          activeController = null;
        }
      };

      const scheduleLookup = (word) => {
        cancelLookup();
        setStatus('æŸ¥è©¢ç¿»è­¯ä¸­â€¦', 'loading');
        lookupDelay = setTimeout(() => performLookup(word), 350);
      };

      const performLookup = async (word) => {
        const controller = new AbortController();
        activeController = controller;

        try {
          const response = await fetch(`/lookup?word=${encodeURIComponent(word)}`, {
            signal: controller.signal,
          });

          if (!response.ok) {
            throw new Error('lookup_failed');
          }

          const data = await response.json();

          if (wordInput.value.trim() !== word) {
            return;
          }

          if (data.status === 'ok' && data.translation) {
            const shouldAutofill =
              !definitionManuallyEdited ||
              !defInput.value.trim() ||
              defInput.dataset.autofillWord === word;

            if (shouldAutofill) {
              defInput.value = data.translation;
              defInput.dataset.autofillWord = word;
              definitionManuallyEdited = false;
              manualEditWord = '';
            }
            if (Array.isArray(data.meanings) && data.meanings.length > 1) {
              setStatus(`å·²å¸¶å…¥å¤šå€‹ç¿»è­¯ï¼š${data.meanings.join('ã€')}ã€‚`, 'success');
            } else {
              setStatus('å·²è‡ªå‹•å¸¶å…¥ç¿»è­¯ï¼Œå¯è¦–éœ€è¦èª¿æ•´ã€‚', 'success');
            }
          } else if (data.status === 'not_found') {
            setStatus('æ‰¾ä¸åˆ°ç¿»è­¯ï¼Œè«‹è‡ªè¡Œè¼¸å…¥ã€‚', 'warning');
          } else {
            setStatus('è«‹è¼¸å…¥å–®å­—ä»¥æŸ¥è©¢ç¿»è­¯ã€‚', 'idle');
          }
        } catch (err) {
          if (err.name === 'AbortError') {
            return;
          }
          setStatus('æŸ¥è©¢ç¿»è­¯å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦æˆ–è‡ªè¡Œè¼¸å…¥ã€‚', 'error');
        } finally {
          if (activeController === controller) {
            activeController = null;
          }
        }
      };

      defInput.addEventListener('input', () => {
        definitionManuallyEdited = true;
        defInput.dataset.autofillWord = '';
        manualEditWord = wordInput.value.trim();
      });

      wordInput.addEventListener('input', () => {
        const word = wordInput.value.trim();

        if (defInput.dataset.autofillWord && defInput.dataset.autofillWord !== word) {
          defInput.value = '';
          defInput.dataset.autofillWord = '';
          definitionManuallyEdited = false;
          manualEditWord = '';
        } else if (
          definitionManuallyEdited &&
          manualEditWord &&
          manualEditWord !== word &&
          !manualEditWord.startsWith(word) &&
          !word.startsWith(manualEditWord)
        ) {
          definitionManuallyEdited = false;
          manualEditWord = '';
          defInput.value = '';
        }

        if (!word) {
          cancelLookup();
          if (!definitionManuallyEdited) {
            defInput.value = '';
          }
          manualEditWord = '';
          setStatus('è«‹è¼¸å…¥å–®å­—ä»¥æŸ¥è©¢ç¿»è­¯ã€‚', 'idle');
          return;
        }

        scheduleLookup(word);
      });

      setStatus('è¼¸å…¥å–®å­—å¾Œæœƒè‡ªå‹•æŸ¥è©¢ç¿»è­¯ã€‚', 'idle');

      const supportsSpeech = 'speechSynthesis' in window && typeof window.SpeechSynthesisUtterance !== 'undefined';
      const speakWord = (text) => {
        if (!supportsSpeech || !text) {
          return;
        }
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'en-US';
        utterance.rate = 0.95;
        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(utterance);
      };

      const addForm = document.querySelector('[data-add-entry]');
      if (addForm) {
        addForm.addEventListener('submit', () => {
          const word = wordInput.value.trim();
          speakWord(word);
        });
      }

      const speakButtons = document.querySelectorAll('[data-speak-word]');
      if (supportsSpeech) {
        speakButtons.forEach((btn) => {
          btn.addEventListener('click', () => {
            const word = btn.getAttribute('data-speak-word');
            speakWord(word);
          });
        });
      } else {
        speakButtons.forEach((btn) => {
          btn.disabled = true;
          btn.classList.add('speak-button--disabled');
          btn.title = 'ç€è¦½å™¨ä¸æ”¯æ´èªéŸ³æ’­æ”¾';
        });
      }

      const updateToggleLabel = (toggle, expanded) => {
        toggle.textContent = expanded ? 'æ”¶èµ·å…§å®¹' : 'å±•é–‹æ›´å¤š';
      };

      const evaluateCollapsible = (container) => {
        const content = container.querySelector('[data-collapsible-content]');
        const toggle = container.querySelector('[data-collapsible-toggle]');
        if (!content || !toggle) {
          return;
        }

        container.dataset.expanded = 'false';
        const isOverflowing = content.scrollHeight > content.clientHeight + 1;
        if (!isOverflowing) {
          container.dataset.expanded = 'true';
          toggle.hidden = true;
        } else {
          toggle.hidden = false;
          updateToggleLabel(toggle, false);
        }
      };

      const collapsibleCells = document.querySelectorAll('[data-collapsible]');
      const refreshCollapsibles = () => {
        collapsibleCells.forEach((cell) => {
          const previouslyExpanded = cell.dataset.expanded === 'true';
          if (!previouslyExpanded) {
            evaluateCollapsible(cell);
          }
        });
      };

      collapsibleCells.forEach((cell) => {
        evaluateCollapsible(cell);
        const toggle = cell.querySelector('[data-collapsible-toggle]');
        const content = cell.querySelector('[data-collapsible-content]');
        if (!toggle || !content) {
          return;
        }
        toggle.addEventListener('click', () => {
          const expanded = cell.dataset.expanded === 'true';
          if (expanded) {
            cell.dataset.expanded = 'false';
            updateToggleLabel(toggle, false);
          } else {
            cell.dataset.expanded = 'true';
            updateToggleLabel(toggle, true);
          }
        });
      });

      window.addEventListener('resize', () => {
        refreshCollapsibles();
      });
    })();
  </script>
{% endblock %}
