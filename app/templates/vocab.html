{% extends "base.html" %}
{% block content %}
<section class="card">
  <h2>å–®å­—æœ¬</h2>
  <p class="section-lead">
    ç›®å‰å…±æ”¶è— <strong>{{ entries|length }}</strong> å€‹å–®å­—ï¼Œä»Šæ—¥å¾…è¤‡ç¿’ <strong>{{ due_count }}</strong> å€‹ã€‚
  </p>
  {% if entries %}
    <div class="vocab-actions">
      <button type="button" id="speak-all" class="btn-secondary">
        ğŸ”Š æœ—è®€å…¨éƒ¨
      </button>
    </div>
    <div class="vocab-list">
      {% for entry in entries %}
        <article
          class="vocab-item"
          data-word="{{ entry.word | e }}"
          data-definition="{{ (entry.definition or '') | e }}"
        >
          <header class="vocab-item__header">
            <div class="vocab-item__title">
              <h3 class="vocab-item__word">
                <span class="vocab-item__word-text">{{ entry.word }}</span>
                {% if entry.definition %}
                  <span class="vocab-item__definition">{{ entry.definition }}</span>
                {% endif %}
              </h3>
            </div>
            <div class="vocab-item__actions">
              <button type="button" class="speak-button" data-word="{{ entry.word }}" aria-label="æ’­æ”¾ {{ entry.word }} çš„ç™¼éŸ³">
                ğŸ”Š ç™¼éŸ³
              </button>
              <form
                method="post"
                action="{{ url_for('delete_entry', entry_id=entry.id) }}"
                class="inline-form"
              >
                <button type="submit" class="btn-link btn-link--danger" aria-label="åˆªé™¤ {{ entry.word }}">
                  åˆªé™¤
                </button>
              </form>
            </div>
          </header>
          {% if entry.context %}
            <div class="vocab-item__body">
              <p class="vocab-item__context">ä¾‹å¥ï¼š{{ entry.context }}</p>
            </div>
          {% endif %}
          <footer class="vocab-item__meta">
            ä¸‹ä¸€æ¬¡è¤‡ç¿’ï¼š{{ entry.next_review }} Â· é€£å‹ {{ entry.success_streak }} Â· å·²è¤‡ç¿’ {{ entry.review_count }} æ¬¡
          </footer>
        </article>
      {% endfor %}
    </div>
  {% else %}
    <p>é‚„æ²’æœ‰ä»»ä½•å–®å­—ï¼Œå¿«åˆ°ã€Œæ–°å¢å–®å­—ã€é é¢é–‹å§‹å»ºç«‹ä½ çš„å–®å­—åº«å§ï¼</p>
  {% endif %}
</section>
{% endblock %}

{% block extra_scripts %}
  <script>
    (function () {
      const supportsSpeech =
        'speechSynthesis' in window && typeof window.SpeechSynthesisUtterance === 'function';
      if (!supportsSpeech) {
        return;
      }

      const queueSpeech = (segments) => {
        if (!segments.length) {
          return;
        }

        const [{ text, lang, rate }, ...rest] = segments;
        const utterance = new SpeechSynthesisUtterance(text);
        if (lang) {
          utterance.lang = lang;
        }
        if (rate) {
          utterance.rate = rate;
        }
        utterance.onend = () => {
          queueSpeech(rest);
        };
        utterance.onerror = () => {
          queueSpeech(rest);
        };
        window.speechSynthesis.speak(utterance);
      };

      const extractDefinitions = (raw) => {
        if (!raw) {
          return [];
        }
        const parts = raw
          .split(/[ï¼›;,ï¼Œ]/)
          .map((part) => part.trim())
          .filter(Boolean);
        if (!parts.length && raw.trim()) {
          parts.push(raw.trim());
        }
        return parts.slice(0, 2);
      };

      const buildSegmentsForEntry = (element) => {
        const word = (element.dataset.word || '').trim();
        const definitionRaw = (element.dataset.definition || '').trim();
        if (!word && !definitionRaw) {
          return [];
        }
        const segments = [];
        if (word) {
          const rates = [0.95, 0.8, 0.95];
          rates.forEach((rate) => {
            segments.push({ text: word, lang: 'en-US', rate });
          });
        }
        extractDefinitions(definitionRaw).forEach((definition) => {
          segments.push({ text: definition, lang: 'zh-TW', rate: 1 });
        });
        return segments;
      };

      const speakEntry = (element) => {
        const segments = buildSegmentsForEntry(element);
        if (!segments.length) {
          return;
        }
        window.speechSynthesis.cancel();
        queueSpeech(segments);
      };

      document.querySelectorAll('.speak-button').forEach((button) => {
        button.addEventListener('click', () => {
          const container = button.closest('.vocab-item');
          if (container) {
            speakEntry(container);
          }
        });
      });

      const speakAllButton = document.getElementById('speak-all');
      if (speakAllButton) {
        speakAllButton.addEventListener('click', () => {
          const items = Array.from(document.querySelectorAll('.vocab-item'));
          const segments = [];
          items.forEach((item) => {
            segments.push(...buildSegmentsForEntry(item));
          });
          if (!segments.length) {
            return;
          }
          window.speechSynthesis.cancel();
          queueSpeech(segments);
        });
      }
    })();
  </script>
{% endblock %}
